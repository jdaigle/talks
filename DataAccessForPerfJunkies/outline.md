or: How I Learned to Stop Worrying and Love the ORM.

ORM frameworks get a bad rap for their performance characteristics and complexity. But like any tool, it's all about learning to use correctly and intelligently. In this session we'll look at how application developers often use (and misuse!) these tools, and identify and correct problematic usage patterns. We'll also discover when it's appropriate to use an ORM, when it's not, and how incorporate "raw" SQL where it makes sense.

Notes	The presentation is geared towards app dev, and uses MSSQL and Entity Framework in examples. But the concepts are general enough to apply to relational DB or ORM.

What is an ORM?
Contrary to belief, it is not a perfomance abyss.
While the name implies a "mapper" (i.e. mapping entities between programming objects and database rows), many
ORM frameworks have many other features: query generation, identity map, unit of work. These can be incredible useful
tools for application developers - they can prevent mistakes by removing a significant amount of boilerplate code.

They can also be a source of serious and non-obvious performance issues.

DBAs: should not fear ORMs
Devs: should not fear SQL
Neither of these are evil, but developers are often misguided by the tooling and so-called "best practices".

Developers should know *and love* SQL.

Real Life Do's and Dont's
- Many-to-many mappings. Map the join table instead.
- Collections in general. It's a performance trap. Many-to-one navigation is okay.
- Don't autogenerate.
- Lazy loading. SELECT 1+N
- Cartesian Products. Rewrite into multiple queries.
- Use projections - avoid returning excessive data.
- Batched queries
- Bad: deferred execution.
- Transactions. Avoid implicit, use explicit.
- DSL on top of SQL. E.g. LINQ can be cryptic. This can lead to performance bugs. Just use SQL!

Tools:
- Learn how to use a ORM profiler (e.g. EF Prof)
- Avoid autogenerated code
- Don't let your application code automatically define or build your database schema
- Migrations are another topic.

Don't use repositories. Abstract API into commands and queries.